name: Deploy to VPS

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.7.0
      with:
        ssh-private-key: ${{ secrets.VPS_SSH_KEY }}
        
    - name: Add VPS to known hosts
      run: |
        mkdir -p ~/.ssh
        ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts
        
    - name: Deploy to VPS
      run: |
        ssh ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
          set -e
          cd /opt/notionlock
          
          # Show current git status
          echo "üìã Current git status:"
          git status --porcelain || true
          
          # Force pull latest changes (discard local changes)
          echo "üì• Pulling latest changes from GitHub..."
          git stash push -m "Auto-stash before deployment $(date)" || true
          git fetch origin master
          git reset --hard origin/master
          git clean -fd
          echo "‚úÖ Repository updated to latest master"
          
          # Show latest commits
          echo "üìù Latest commits:"
          git log --oneline -3
          
          # Copy production environment (backup existing if present)
          echo "üîß Setting up production environment..."
          if [ -f .env ]; then
            cp .env .env.backup.$(date +%Y%m%d_%H%M%S) || true
          fi
          cp .env_prod .env
          echo "‚úÖ Production environment configured"
          
          # Backup database (optional safety net)
          echo "üíæ Creating database backup..."
          docker compose -f docker/docker-compose.yml exec postgres pg_dump -U ${DB_USER:-notionlock} ${DB_NAME:-notionlock} > backup_$(date +%Y%m%d_%H%M%S).sql || echo "‚ö†Ô∏è Backup failed, but continuing deployment"
          
          # Nuclear option: FRONTEND ONLY rebuild (preserve database!)
          echo "‚ò¢Ô∏è FRONTEND REBUILD: Removing frontend traces (DB preserved)..."
          docker compose -f docker/docker-compose.yml stop frontend || true
          docker compose -f docker/docker-compose.yml rm -f frontend || true
          
          # Remove ONLY frontend images (be very specific)
          echo "üóëÔ∏è Removing frontend images only..."
          docker images | grep "notionlock.*frontend\|notionlock-frontend" | awk '{print $3}' | xargs -r docker rmi -f 2>/dev/null || true
          
          # Verify database is still running
          echo "üîç Checking database status..."
          if docker compose -f docker/docker-compose.yml ps postgres | grep -q "Up"; then
            echo "‚úÖ Database container is running - data preserved!"
          else
            echo "‚ö†Ô∏è Database container not running - will restart with existing data"
          fi
          
          # Clean ALL docker cache
          echo "üßπ Nuclear cleaning of Docker cache..."
          docker builder prune -af || true
          docker system prune -f || true
          
          # Pull base images
          echo "üì• Pulling base images..."
          docker compose -f docker/docker-compose.yml pull postgres redis || true
          
          # Build frontend completely fresh
          echo "üî® Building frontend from absolute scratch..."
          DOCKER_BUILDKIT=0 docker compose -f docker/docker-compose.yml --env-file .env build --no-cache --pull frontend
          
          # Start all containers (database will use existing data)
          echo "üöÄ Starting all containers..."
          docker compose -f docker/docker-compose.yml --env-file .env up -d
          
          # Verify database data integrity
          echo "üîç Checking database data..."
          sleep 10
          USER_COUNT=$(docker compose -f docker/docker-compose.yml exec postgres psql -U ${DB_USER:-notionlock} -d ${DB_NAME:-notionlock} -t -c "SELECT COUNT(*) FROM users;" 2>/dev/null || echo "0")
          echo "üìä Users in database: ${USER_COUNT}"
          
          PAGE_COUNT=$(docker compose -f docker/docker-compose.yml exec postgres psql -U ${DB_USER:-notionlock} -d ${DB_NAME:-notionlock} -t -c "SELECT COUNT(*) FROM protected_pages;" 2>/dev/null || echo "0")
          echo "üìä Protected pages: ${PAGE_COUNT}"
          
          # Wait for containers
          echo "‚è≥ Waiting for containers to initialize..."
          sleep 15
          
          # Check container status
          echo "üìä Container status:"
          docker compose -f docker/docker-compose.yml ps
          
          # Verify frontend is accessible
          echo "üîç Checking if frontend build completed..."
          if docker compose -f docker/docker-compose.yml exec frontend ls /usr/share/nginx/html/index.html >/dev/null 2>&1; then
              echo "‚úÖ Frontend build completed successfully!"
          else
              echo "‚ùå Frontend build verification failed"
              exit 1
          fi
          
          # Clean up old images
          echo "üßπ Final cleanup..."
          docker image prune -f || true
          
          echo "üéâ Deployment completed successfully!"
        EOF
        
    - name: Verify deployment
      run: |
        # Wait a moment for containers to start
        sleep 30
        
        # Check if API is responding
        if curl -f https://api.notionlock.com/api/health; then
          echo "‚úÖ API is healthy"
        else
          echo "‚ùå API health check failed"
          exit 1
        fi
        
        # Check if frontend is responding
        if curl -f https://notionlock.com; then
          echo "‚úÖ Frontend is responding"
        else
          echo "‚ùå Frontend check failed"
          exit 1
        fi